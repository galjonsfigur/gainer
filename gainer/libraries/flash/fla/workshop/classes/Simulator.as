//非常にシンプルな物理シミュレーター/*参考文献http://www.cove.org/ape/http://www.harveycartel.org/metanet/tutorials.html*/class Simulator {		//重力加速度	public var gravity:Number = 1;		//このシミュレーターで管理する剛体リスト	public var objects:Array;		function Simulator() {		objects = new Array();	}		//シミュレーターに剛体を追加する	public function addObject(body:RigidBody) {		objects.push(body);		body.simulator = this;	}		//シミュレーターから剛体を取り除く	public function removeObject(body:RigidBody) {		var id:Number = -1;		for(var i = 0; i < objects.length; ++i) {			if(objects[i] == body) {				id = i;				break;			}		}		if (id != -1) {			body.removeMovieClip();			objects.splice(id, 1);		}	}		//シミュレーションを更新する	public function update() {				//全ての剛体を更新する		for(var i = 0; i < objects.length; ++i) {			objects[i].update();		}				//全ての剛体に関して、衝突判定をする		for (var j:Number = 0; j < objects.length; j++) {						var bodyA:RigidBody = objects[j];						for (var i:Number = j + 1; i < objects.length; i++) {								var bodyB:RigidBody = objects[i];								//2つの剛体が共にCircleクラスであれば、円同士の衝突判定を行う				if(bodyA instanceof Circle && bodyB instanceof Circle) testCircleCircle(Circle(bodyA), Circle(bodyB));								//2つの剛体がCircleクラスとStaticRectangleクラスであれば、円とボックスの衝突判定を行う				else if(bodyA instanceof Circle && bodyB instanceof StaticRectangle) testRectCircle(StaticRectangle(bodyB), Circle(bodyA));				else if(bodyA instanceof StaticRectangle && bodyB instanceof Circle) testRectCircle(StaticRectangle(bodyA), Circle(bodyB));			}		}	}		//円同士の衝突判定を行う	private static function testCircleCircle(ca:Circle, cb:Circle):Void {				//円の中心から、他方の円の中心に向かうベクトル		var collisionNormal:Vector = ca.position.minus(cb.position);				//円同士の距離		var mag:Number = collisionNormal.magnitude();				//円同士の交わりの深さ		var collisionDepth:Number = (ca.radius + cb.radius) - mag;				//円同士が衝突していれば		if (collisionDepth > 0) {						//衝突面の法線ベクトルを求める			collisionNormal.divEquals(mag);						//衝突の解決を行う			Simulator.resolve(ca, cb, collisionNormal, collisionDepth);		}	}		//ボックスと円の衝突判定を行う	private static function testRectCircle(ra:StaticRectangle, ca:Circle):Void {				var collisionNormal:Vector;		var collisionDepth:Number = Number.POSITIVE_INFINITY;		var depths:Array = new Array(2);				//ボックスの辺との衝突を考慮する		for (var i:Number = 0; i < 2; i++) {			var boxAxis:Vector = ra.axes[i];						//ボックスの各軸に平行な直線上に、ボックスと円をそれぞれ射影し、交わりの深さを求める			var depth:Number = testRanges(ra.getProjection(boxAxis), ca.getProjection(boxAxis));			if (depth == 0) return;						//ボックスの各軸上で計算した交わりの深さのうち、小さい方を採用する			if (Math.abs(depth) < Math.abs(collisionDepth)) {				collisionNormal = boxAxis;				collisionDepth = depth;			}			depths[i] = depth;		}					//ボックスの頂点との衝突を考慮する		var r:Number = ca.radius;		if (Math.abs(depths[0]) < r && Math.abs(depths[1]) < r) {						//ボックスの頂点のうち円に最も近い頂点の座標を得る			var vertex:Vector = closestVertexOnRect(ca.position, ra);				//円の中心からボックスの最寄りの頂点へと向かうベクトルを衝突の法線とする			collisionNormal = vertex.minus(ca.position);						//交わりの深さを求める			var mag:Number = collisionNormal.magnitude();			collisionDepth = r - mag;						//衝突している場合、法線ベクトルを正規化する			if (collisionDepth > 0) collisionNormal.divEquals(mag);			else return;		}				//衝突の解決を行う		Simulator.resolve(ra, ca, collisionNormal, collisionDepth);	}		//二つの区間のオーバーラップしている長さを求める	private static function testRanges(rangeA:Object, rangeB:Object):Number {					if (rangeA.max < rangeB.min) return 0;		if (rangeB.max < rangeA.min) return 0;					var lenA:Number = rangeB.max - rangeA.min;		var lenB:Number = rangeB.min - rangeA.max;					return (Math.abs(lenA) < Math.abs(lenB)) ? lenA : lenB;	}		//ある点から、最も近いボックス上の頂点座標を求める	private static function closestVertexOnRect(p:Vector, r:StaticRectangle):Vector {			var d:Vector = p.minus(r.position);		var q:Vector = new Vector(r.position.x, r.position.y);			for (var i:Number = 0; i < 2; i++) {			var dist:Number = d.dot(r.axes[i]);				if (dist >= 0) dist = r.extents[i];			else if (dist < 0) dist = -r.extents[i];				q.plusEquals(r.axes[i].mult(dist));		}		return q;	}		//衝突を解決する	private static function resolve(bodyA:RigidBody, bodyB:RigidBody, normal:Vector, depth:Number) {				//交わっている状態から、接している状態まで押し戻すベクトル		var mtd:Vector = normal.mult(depth);				//トータルの反発係数		var te:Number = bodyA.elasticity + bodyB.elasticity;				//トータルの摩擦		var tf:Number = 1 - (bodyA.friction + bodyB.friction);		if (tf > 1) tf = 1;		else if (tf < 0) tf = 0;				//トータルの質量		var ma:Number = bodyA.mass;		var mb:Number = bodyB.mass;		var tm:Number = ma + mb;				//各剛体の速度の法線方向成分と接線方向成分を求める		var vdotnA:Number = normal.dot(bodyA.velocity);		var cvnA:Vector = normal.mult(vdotnA);		var cvtA:Vector = bodyA.velocity.minus(cvnA);		var vdotnB:Number = normal.dot(bodyB.velocity);		var cvnB:Vector = normal.mult(vdotnB);		var cvtB:Vector = bodyB.velocity.minus(cvnB);				//衝突後の法線方向の速度を求める		var vnA:Vector = (cvnB.mult((te + 1) * mb).plus(cvnA.mult(ma - te * mb))).divEquals(tm);				var vnB:Vector = (cvnA.mult((te + 1) * ma).plus(cvnB.mult(mb - te * ma))).divEquals(tm);				//衝突後の接線方向の速度を求める		cvtA.multEquals(tf);		cvtB.multEquals(tf);				//剛体クラスごとの衝突解決を行う		bodyA.resolve(mtd.mult( mb / tm), vnA.plusEquals(cvtA), normal, depth, -1);		bodyB.resolve(mtd.mult(-ma / tm), vnB.plusEquals(cvtB), normal, depth,  1);	}}