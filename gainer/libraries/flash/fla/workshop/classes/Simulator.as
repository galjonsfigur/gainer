class Simulator {		public var gravity:Number = 1;	public var objects:Array;		function Simulator() {		objects = new Array();	}		public function addObject(body:RigidBody) {		objects.push(body);		body.simulator = this;	}		public function removeObject(body:RigidBody) {		var ppos:Number = -1;		for(var i=0; i<objects.length; ++i) {			if(objects[i] == body) {				ppos = i;				break;			}		}		if (ppos == -1) return;		body.removeMovieClip();		objects.splice(ppos, 1);	}		public function update() {				for(var i = 0; i < objects.length; ++i) {			objects[i].update();		}				for (var j:Number = 0; j < objects.length; j++) {							var bodyA:RigidBody = objects[j];							for (var i:Number = j + 1; i < objects.length; i++) {								var bodyB:RigidBody = objects[i];								if(bodyA instanceof Circle && bodyB instanceof Circle) testCircleCircle(Circle(bodyA), Circle(bodyB));				else if(bodyA instanceof Circle && bodyB instanceof StaticRectangle) testRectCircle(StaticRectangle(bodyB), Circle(bodyA));				else if(bodyA instanceof StaticRectangle && bodyB instanceof Circle) testRectCircle(StaticRectangle(bodyA), Circle(bodyB));			}		}	}		private static function testCircleCircle(ca:Circle, cb:Circle):Void {		var collisionNormal:Vector = ca.position.minus(cb.position);		var mag:Number = collisionNormal.magnitude();		var collisionDepth:Number = (ca.radius + cb.radius) - mag;		if (collisionDepth > 0) {			collisionNormal.divEquals(mag);			Simulator.resolve(ca, cb, collisionNormal, collisionDepth);		}	}		private static function testRectCircle(ra:StaticRectangle, ca:Circle):Void {					var collisionNormal:Vector;		var collisionDepth:Number = Number.POSITIVE_INFINITY;		var depths:Array = new Array(2);					for (var i:Number = 0; i < 2; i++) {			var boxAxis:Vector = ra.axes[i];			var depth:Number = testRanges(ra.getProjection(boxAxis), ca.getProjection(boxAxis));			if (depth == 0) return;				if (Math.abs(depth) < Math.abs(collisionDepth)) {				collisionNormal = boxAxis;				collisionDepth = depth;			}			depths[i] = depth;		}						var r:Number = ca.radius;		if (Math.abs(depths[0]) < r && Math.abs(depths[1]) < r) {				var vertex:Vector = closestVertexOnRect(ca.position, ra);				collisionNormal = vertex.minus(ca.position);			var mag:Number = collisionNormal.magnitude();			collisionDepth = r - mag;				if (collisionDepth > 0) collisionNormal.divEquals(mag);			else return;		}		Simulator.resolve(ra, ca, collisionNormal, collisionDepth);	}		private static function testRanges(rangeA:Object, rangeB:Object):Number {					if (rangeA.max < rangeB.min) return 0;		if (rangeB.max < rangeA.min) return 0;					var lenA:Number = rangeB.max - rangeA.min;		var lenB:Number = rangeB.min - rangeA.max;					return (Math.abs(lenA) < Math.abs(lenB)) ? lenA : lenB;	}		private static function closestVertexOnRect(p:Vector, r:StaticRectangle):Vector {			var d:Vector = p.minus(r.position);		var q:Vector = new Vector(r.position.x, r.position.y);			for (var i:Number = 0; i < 2; i++) {			var dist:Number = d.dot(r.axes[i]);				if (dist >= 0) dist = r.extents[i];			else if (dist < 0) dist = -r.extents[i];				q.plusEquals(r.axes[i].mult(dist));		}		return q;	}		private static function resolve(bodyA:RigidBody, bodyB:RigidBody, normal:Vector, depth:Number) {		//干渉を解決するベクトル		var mtd:Vector = normal.mult(depth);							var te:Number = bodyA.elasticity + bodyB.elasticity;		var tf:Number = 1 - (bodyA.friction + bodyB.friction);		if (tf > 1) tf = 1;		else if (tf < 0) tf = 0;				var ma:Number = bodyA.mass;		var mb:Number = bodyB.mass;		var tm:Number = ma + mb;							var vdotnA:Number = normal.dot(bodyA.velocity);		var cvnA:Vector = normal.mult(vdotnA);		var cvtA:Vector = bodyA.velocity.minus(cvnA);		var vdotnB:Number = normal.dot(bodyB.velocity);		var cvnB:Vector = normal.mult(vdotnB);		var cvtB:Vector = bodyB.velocity.minus(cvnB);							var vnA:Vector = (cvnB.mult((te + 1) * mb).plus(cvnA.mult(ma - te * mb))).divEquals(tm);				var vnB:Vector = (cvnA.mult((te + 1) * ma).plus(cvnB.mult(mb - te * ma))).divEquals(tm);		cvtA.multEquals(tf);		cvtB.multEquals(tf);							bodyA.resolve(mtd.mult( mb / tm), vnA.plusEquals(cvtA), normal, depth, -1);		bodyB.resolve(mtd.mult(-ma / tm), vnB.plusEquals(cvtB), normal, depth,  1);	}}